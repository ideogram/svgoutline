"""
Utilities for manipulating/querying aspects of SVGs relevant to this
application (not a generic SVG library). All methods expect SVGs parsed as XML
using Python's ElementTree library.
"""

import re


# Relevant XML namespace URIs used by SVGs
SVG_NAMESPACE = "http://www.w3.org/2000/svg"
INKSCAPE_NAMESPACE = "http://www.inkscape.org/namespaces/inkscape"
XLINK_NAMESPACE = "http://www.w3.org/1999/xlink"

namespaces = {
    "svg": SVG_NAMESPACE,
    "inkscape": INKSCAPE_NAMESPACE,
    "xlink": XLINK_NAMESPACE,
}

# Unit conversion ratios
MM_PER_CM = 10.0
MM_PER_QUARTER_MM = 0.25
MM_PER_INCH = 25.4
MM_PER_PICA = MM_PER_INCH / 6.0
MM_PER_POINT = MM_PER_INCH / 72.0


def css_dimension_to_mm(dimension, pixels_per_mm=96.0/MM_PER_INCH):
    """
    Convert a CSS dimension string (e.g. '3cm') into a number of mm. Fails for
    non-absolute units of size.
    """
    match = re.match(r"^\s*[+]?\s*([0-9.]+)\s*(cm|mm|Q|in|pc|pt|px|)\s*$",
                     dimension)
    if not match:
        raise ValueError("{} is not a positive, absolute unit of size".format(
            repr(dimension)))

    number, unit = match.groups()
    number = float(number)

    if unit == "mm":
        pass
    elif unit == "cm":
        number *= MM_PER_CM
    elif unit == "Q":
        number *= MM_PER_QUARTER_MM
    elif unit == "in":
        number *= MM_PER_INCH
    elif unit == "pc":
        number *= MM_PER_PICA
    elif unit == "pt":
        number *= MM_PER_POINT
    elif unit == "px" or unit == "":
        number /= pixels_per_mm
    else:
        assert False, "Supposedly-supported unit not implemented!"

    return number


def get_svg_page_size(root):
    """
    Given an ElementTree-parsed SVG file, return a (width_mm, height_mm) pair
    giving the page dimensions in mm.

    This function correctly handles SVGs generated by Inkscape prior to
    Version 0.92 which assumed 90 DPI pixels rather than the 96 DPI pixels
    specified by the SVG/CSS specifications.
    """

    assert root.tag == "svg" or root.tag == "{{{}}}svg".format(SVG_NAMESPACE)

    # As per the CSS spec
    dpi = 96

    # Certain older Inkscape versions used the wrong DPI
    inkscape_version = root.attrib.get(
        "{{{}}}version".format(INKSCAPE_NAMESPACE))
    if inkscape_version:
        version_number = inkscape_version.partition(" ")[0]
        version_number_tuple = tuple(map(int, version_number.split(".")))
        if version_number_tuple < (0, 92, 0):
            dpi = 90

    pixels_per_mm = dpi / MM_PER_INCH

    try:
        width = root.attrib["width"]
        height = root.attrib["height"]
    except KeyError:
        raise ValueError(
            "'width' and 'height' must be specified for <svg> tag.")

    width_mm = css_dimension_to_mm(width, pixels_per_mm)
    height_mm = css_dimension_to_mm(height, pixels_per_mm)

    return (width_mm, height_mm)


def convert_polylines_to_path(root):
    """
    Given an ElementTree-parsed SVG file, finds all line, polyline and polygon elements,
    converts these into path elements and returns the converted ElementTree.

    This conversion is needed to circumvent a bug in the PySide (or QT?) library that prevents
    these element being parsed correctly in outline_painter.py
    """

    for element in root.findall(".//{*}line"):
        element.tag = "path"
        x1, y1, x2, y2 = [element.attrib.pop(attr) for attr in ("x1", "y1", "x2", "y2")]
        element.set("d", f"M {x1} {y1} L {x2} {y2}")

    for element in root.findall(".//{*}polyline"):
        element.tag = "path"
        points = element.attrib.pop("points")
        element.set("d", _polyline2pathd(points))

    for element in root.findall(".//{*}polygon"):
        element.tag = "path"
        points = element.attrib.pop("points")
        element.set("d", _polygon2pathd(points))

    return root


# The following code is borrowed (and ever so slightly altered) from the svgpathtools package by
# mathandy: https://github.com/mathandy/svgpathtools (nov. 2023)

"""Regular expression to match the coordinate pairs contained in the SVG-Polyline and Polygon 'points'-attribrute:"""
COORD_PAIR_TMPLT = re.compile(
    r'([\+-]?\d*[\.\d]\d*[eE][\+-]?\d+|[\+-]?\d*[\.\d]\d*)' +
    r'(?:\s*,\s*|\s+|(?=-))' +
    r'([\+-]?\d*[\.\d]\d*[eE][\+-]?\d+|[\+-]?\d*[\.\d]\d*)'
)


def _polyline2pathd(polyline: str, is_polygon=False):
    """converts the string from a polyline points-attribute to a string for a
    Path object d-attribute"""

    points = COORD_PAIR_TMPLT.findall(polyline)

    closed = (float(points[0][0]) == float(points[-1][0]) and
              float(points[0][1]) == float(points[-1][1]))

    # The `parse_path` call ignores redundant 'z' (closure) commands
    # e.g. `parse_path('M0 0L100 100Z') == parse_path('M0 0L100 100L0 0Z')`
    # This check ensures that an n-point polygon is converted to an n-Line path.
    if is_polygon and closed:
        points.append(points[0])

    d = 'M' + 'L'.join('{0} {1}'.format(x,y) for x,y in points)
    if is_polygon or closed:
        d += 'z'
    return d


# Borrowed from svgpathtools package:
def _polygon2pathd(polyline):
    """converts the string from a polygon points-attribute to a string
    for a Path object d-attribute.
    Note:  For a polygon made from n points, the resulting path will be
    composed of n lines (even if some of these lines have length zero).
    """
    return _polyline2pathd(polyline, True)


# (end of code borrowed from svgpathtools)

